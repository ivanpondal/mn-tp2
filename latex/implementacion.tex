\subsection{Page Rank con matriz Esparsa}
A la hora de implementar Page Rank con matriz Esparsa utilizamos \textsc{C++}, lenguaje que nos permite realizar mediciones temporales precisas, como asi tambien utilizar nuestras propias estructuras de datos.
Recordemos que elegimos el \textit{Dictionary of Keys (dok)} para representar las matrices esparsas. El mismo consiste en un vector de diccionarios, en donde las posiciones del vector representan filas y las keys de los diccionarios las columnas.
A su vez es necesario tener en cuenta que los datos de entrada nos son provistos de la siguiente forma:
\begin{itemize}
	\item Cantidad de nodos ($n$) y cantidad de links salientes ($m$).
	\item $m$ lineas con pares $i$, $j$, donde $i$ tiene un link hacia $j$.
\end{itemize}
Los paso para realizar Page Rank son los siguientes:

\begin{enumerate}
	\item Leemos los datos de entrada y luego generamos $P$.
	\begin{lstlisting}
	Leer n, m del input
	Crear un vector de diccionarios vacios, A, de tamano n
	Crear un vector tamano n, links_salientes, inicializado en 0
	Para k=0 hasta m-1 hacer:
		Leer i,j del input
		Crear la key i-1 con 1 como valor asociado en el diccionario de A[j-1]
		Sumar 1 al contenido de links_salientes[i-1]
	Fin Para
	Para i=0 hasta n-1 hacer:
		Iterar en el diccionario de A[i]:
			Actualizar los valores asociados a las keys con el valor 1 / links_salientes[key]
		Fin Iteracion
	Fin Para
	\end{lstlisting}
	Vale la pena aclarar que utilizamos \textit{links_salientes} para calcular los $n_j$ necesarios para luego calcular los valores de $P$.

	\item Calculamos el autovector asociado a 1 con el metodo de la Potencia con $P$, normalizando el autovector obtenido.
	\begin{lstlisting}
	Definir una precision
	Definir c como el factor de teletransportacion
	Crear un vector, x, con valores aleatorios de 1 a 50 de tamanio n
	Crear un vector, v, con 1/n como valores de tamanio n
	Crear un vector, y, igual a x
	Crear dos numeros flotantes, delta y ultimo_delta, inicializados en INFINITY y 0 respectivamente.
	Hacer:
		x = y
		y = esparsaPorVector(P, x)
		y = escalarPorVector(y, c)
		w = normaUno(x) - normaUno(y)
		y = sumaVectores(y + escalarPorVector(w, v))
		ultimo_delta = delta
		delta = phi(x) / phi(y)
	Mientras (delta - utimo_delta) > precision
	Normalizar y
	\end{lstlisting}
	A continuacion describimos el procedimiento auxiliar esparsaPorVector:
	\begin{lstlisting}
	esparsaPorVector(matriz esparsa P, vector x):
		Crear vector, y, de tamano n
		Para i = 0 hasta n-1 hacer:
			flotante, suma, inicializado en 0
			Itero sobre las keys del diccionario en P[i]:
				entero j = key
				suma = (valor de la key)*x[j]
			Fin de la Iteracion
			y[i] = suma
		Fin del Para
		Devolver y
	\end{lstlisting}
	El procedimiento phi consiste en calcular la norma infinito del vector pasado por parametro, con la variacion de no tomar el modulo de las componentes del vector.
	Los procedimientos auxiliares escalarPorVector, sumaVectores, normaUno y phi son procedimientos estandar, por lo cual no los detallamos.

	\item Generamos el ranking a partir del autovector y calculado en el paso previo.
	\begin{lstlisting}
	Crear un vector de pares posicion y valor, llamado ranking, de tamano n
	Para i=0 hasta n-1 hacer:
		ranking[i] = par(i, y[i])
	Fin Para
	Ordenar ranking segun sus valores
	\end{lstlisting}
	Para ordenar el vector ranking utilizamos el procedimiento que nos provee \textit{C++},  \texttt{sort}\footnote{http://en.cppreference.com/w/cpp/algorithm/sort}


\end{enumerate}

\subsection{Scripts Rankings Deportivos}

Para los dos modelos siendo estudiados, GeM y el sistema de puntaje de la AFA,
decidimos implementarlos com scripts para \textsc{MATLAB/Octave}, dado que lo que nos
interesaba era analizar los resultados de los mismos y no analizar su tiempo de
cómputo u otro atributo relacionado a su implementación.

\subsubsection{GeM}

El script posee varios parámetros de entrada que pasamos a describir a
continuación:

\begin{itemize}
	\item \textbf{in_filename:} Dirección de archivo con datos de entrada.
	\item \textbf{out_filename:} Dirección de archivo donde escribir el
	resultado final.
	\item \textbf{team_codes_filename:} Archivo opcional con el número de equipo
	asociado a su nombre correspondiente.
	\item \textbf{c:} Parámetro de amortiguación descrito en la
	sección \ref{sec:gem_model} (Por defecto 0.85).
	\item \textbf{date_limit:} Campo opcional con la cantidad de fechas a tomar
	en cuenta (Por defecto toma todas las fechas disponibles).
\end{itemize}

Ahora explicaremos el código desarrollado:

\begin{enumerate}
	\item Leemos la cantidad de equipos y partidos para después cargar todos los
	partidos disponibles y generar nuestra matriz $A$.
	\begin{lstlisting}
	Cargar numero de partidos y equipos
	Crear matriz A de tamanio equipos*equipos llena de 0s
	Mientras partidos > 0
		Cargo numero de fecha del partido junto a los equipos y el resultado
		Si habia limite de fecha y ya se cumplio
			partidos = 0
		Si no
			Si el primer equipo perdio
				A[numero primer equipo][numero segundo equipo] += diferencia de puntos
			Si el segundo equipo perdio
				A[numero segundo equipo][numero primer equipo] += diferencia de puntos
			Fin si
		Fin si
		Decremento partidos en uno
	Fin mientras
	\end{lstlisting}

	\item Generamos la matriz $H$.
	\begin{lstlisting}
	Crear matriz H de tamanio equipos*equipos llena de 0s
	Crear vector a de tamanio equipos lleno de 0s
	Para i de 1 a equipos
		sumaFila = suma total de elementos en fila i de A
		Si la suma > 0
			La fila i de H seran todos los elementos de la fila i de A
			cada uno dividido por sumaFila
		Si no
			Pongo un 1 en la posicion i del vector a
		Fin si
	Fin para
	\end{lstlisting}

	\item Generamos la matriz $G$.
	\begin{lstlisting}
	Crear vector e de tamanio equipos lleno de 1s
	Crear vector u para equipos invictos con todos elementos 1/equipos
	Crear vector v para teletransportacion con todos elementos 1/equipos
	Crear matriz G como resultado de hacer
	G = c*[H + a*transponer(u)] + (1 - c)*e*transponer(v)
	\end{lstlisting}

	\item Busco el autovector asociado al autovalor $\lambda = 1$.
	\begin{lstlisting}
	Generar matrices V y l de autovectores y autovalores de mi matriz G transpuesta
	V es una matriz con autovectores como columnas
	l es una matriz con autovalores en su diagonal
	i = 1
	Mientras valorAbsoluto(l[i][i] - 1) > 0.0001
		Incremento i en una unidad
	Fin mientras
	Crear vector x correspondiente a la columna i de la matriz V
	\end{lstlisting}

	\item Normalizo el vector solución.
	\begin{lstlisting}
	x = valorAbsolutoACadaElemento(x)/sumaElementos(valorAbsolutoACadaElemento(x))
	\end{lstlisting}

	\item Genero matriz de solución.
	\begin{lstlisting}
	Crear matriz S de tamanio equipos*2 y llena de 0s
	Para i de 1 a equipos
		S[i][1] = i
		S[i][2] = x[i]
	Fin para
	\end{lstlisting}

	\item Ordeno y escribo la matriz solución.
	\begin{lstlisting}
	Ordenar crecientemente por segundo elemento de filas la matriz S (ranking)
	Si tengo archivo con nombres de equipos
		Creo mapa teamcodes con cada numero de equipo asociado a su nombre
	Fin si

	Si tengo nombres de equipos cargados
		Para i de 0 a equipos - 1
			Escribo numero, nombre y ranking del equipo numero equipos - i
		Fin para
	Si no
		Para i de 0 a equipos - 1
			Escribo numero y ranking del equipo numero equipos - i
		Fin para
	Fin si
	\end{lstlisting}

\end{enumerate}

\subsubsection{Puntaje AFA}

Para el script utilizado para calcular el puntaje según el criterio de la AFA
los parámetros son los siguientes:

\begin{itemize}
	\item \textbf{in_filename:} Dirección de archivo con datos de entrada.
	\item \textbf{out_filename:} Dirección de archivo donde escribir el
	resultado final.
	\item \textbf{team_codes_filename:} Archivo opcional con el número de equipo
	asociado a su nombre correspondiente.
	\item \textbf{date_limit:} Campo opcional con la cantidad de fechas a tomar
	en cuenta (Por defecto toma todas las fechas disponibles).
\end{itemize}

Pasamos a describir el código:

\begin{enumerate}
	\item Leemos la cantidad de equipos y partidos para después cargar todos los
	partidos disponibles y generar nuestra matriz $S$.
	\begin{lstlisting}
	Cargar numero de partidos y equipos
	Crear matriz S de tamanio equipos*2 llena de 0s
	Mientras partidos > 0
		Cargo numero de fecha del partido junto a los equipos y el resultado
		Si habia limite de fecha y ya se cumplio
			partidos = 0
		Si no
			Si hubo empate
				S[numero primer equipo] += 1
				S[numero segundo equipo] += 1
			Si gano el primer equipo
				S[numero primer equipo] += 3
			Si gano el segundo equipo
				S[numero segundo equipo] += 3
			Fin si
		Fin si
		Decremento partidos en uno
	Fin mientras
	\end{lstlisting}

	\item Ordeno y escribo la matriz solución.
	\begin{lstlisting}
	Ordenar crecientemente por segundo elemento de filas la matriz S (ranking)
	Si tengo archivo con nombres de equipos
		Creo mapa teamcodes con cada numero de equipo asociado a su nombre
	Fin si

	Si tengo nombres de equipos cargados
		Para i de 0 a equipos - 1
			Escribo numero, nombre y ranking del equipo numero equipos - i
		Fin para
	Si no
		Para i de 0 a equipos - 1
			Escribo numero y ranking del equipo numero equipos - i
		Fin para
	Fin si
	\end{lstlisting}

\end{enumerate}
